// 주석
//  설명 역할, 코드로 인식되지 않는다.

int main()
{
	// 자료형 (크기 단위, 1byte = 8bit) Data Type
	// 정수형 : char(1), short(2), int(4), long(4), long long(8)
	// 실수형 : float(4), double(8)
	int i = 0;
	unsigned char c = 0; // 양의 정수만

	c = 0; // 256가지 -> 0~255
	c = 256; // 1 0000 0000 => 8개만 읽으면 0	9번째 비트는 1바이트에 담을 수 없기 때문에 무시

	// 기본적으로 signed로 되어있고 생략되있다.
	signed c1 = 0; // 256가지 -> -128~127
	// 맨끝(왼쪽끝) Most Siginficant Bit(MSD) 0: 양수, 1: 음수
	c1 = -1;

	// 컴퓨터는 모든 연산을 가산으로 처리하기 때문에
	// 음수의 접근방식을 바꿔서 생각해야 한다.
	// 컴퓨터 에게 음수란 10 + (-10) = 0 -> 즉, 더했을 때 모든 비트가 0이 되버리면 음수이다.
	// 따라서 0000 0001 + 1111 1111 = 1 0000 0000 이 되므로 255는 -1이 된다. 따라서 1000 0001 = -128 이 된다. 반대도 가능하다!

	c = 255; // 255
	c1 = 255; // -1
	// 질문 : c와 c1의 비트상태는 다를까?
	// 답 : 아니다
	// c = 255; 와 c1 = 255; 둘의 비트 상태는 같다. c 는 255가 출력되고 c1는 음수를 표현하기때문에 -1로 출력된다.
	// 메모리안에 들어있는 값이 같아도 어떻게 해석하는가에 따라서 출력 값이 달라진다.

	// 음의 정수 찾기(2의 보수법)
	// 대응되는 양수의 부호를 반전 후, 1을 더한다.

	// long과 int둘 다 4바이트인데 뭔차이냐?
	// 원래 long이 4바이트로 설계 怜 int는 가변적으로 사용하는 거였는데
	// 사용하다보니 int도 4바이트가 榮

	// 컴퓨터에서 실수는 부동소수점으로 동작한다
	// 정수형 방식과 실수 표현 방식은 다르다
	// 실수 표현방식은 정밀도에 의존한다.
	// 따라서 double(8) 자료형이 float(4) 보다 더 아래의 소수점까지 정확하게 표현이 가능하다.

	// 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.
	float f = 10.2415f + (float)20;

	
	// 연산자
	// 대입연산자, =

	// 산술 연산자
	// +, -, *, /, %(모듈러스, 나머지, 피연산자가 모두 정수일때만 가능)
	// ++, --
	int data = 10 + 10; // 연산자 사이에 순서가 있다. = 대입연산자도 연산자이다.
	data = data + 20;
	data += 20; // 위에 수식과 같은 뜻이다.

	// data = 10. % 3.;
	// data = (int)(10. / 3.); // 형변환
	// 10.1 -> 디폴트는 double(8)로보고, 뒤에 10.1f를 붙이면 float(4)로 본다.


	// 보통 증감연산자를 ++: 1증가한다. --: 1감소한다 라고 설명한는데
	// 증감연산자 -> 한단계 증가 또는 감소 개념으로 생각하자.
	// 포인터나 수행되는 위치에 따라서 개념이 달라질 수 있기 때문이다.

	data = 0;
	++data; // 전위(전치)
	data++; // 후위(후치)
	// 후위의 경우 모든 연산자(대입연산자)보다 순서가 늦게 수행된다.

	data = 0;
	int a = 10;
	data = a++; // 이경우 10을 data에 넣고 a가 1증가한다. ++가 대입연산자보다 늦게 수행되기 때문이다.
	// 증감연산자는 변수자체의 메모리의 값을 증가시키기 때문에 따로 대입하거나 할 필요가 없다.


	// 논리 연산자
	// !(역, 반전), &&(곱, and), ||(합, or)
	// 참(True), 거짓(False)
	// 참   : 0 이 아닌 값, 보통 1
	// 거짓 : 0

	// cpp 에서 키워드로 값을 사용할 수 있게 해준다.
	true; // 0이 아닌값
	false; // 0 값

	// bool 자료형
	// 0 또는 1 밖에 모르는 바보
	bool TorF = 100; // 0이 아닌 모든 수는 True 즉 1이 저장된다.
	// bool 도 정수형 자료형으로 볼 수 있으며 0과 1만 사용한다. 크기는 1바이트다.

	int iTrue = 100;
	iTrue = !iTrue;
	// 논리연산자 ! 를 일반자료형에서 쓰면 Ture 또는 False로 받아들여 연산해준다.
	// 즉, 0이 아닌 모든 수는 True로 본다음 -> false인 0값으로 반전시켜 주고
	// False일 경우 1로 반전시켜서 준다.

	iTrue = 0;
	iTrue = 100 && 200; // 논리곱(and) 양쪽다 같으면 참, 하나라도 다르면 거짓
	iTrue = 0 || 1; // 논리합(or) 하나라도 참이면 

	// 비교연산자
	// ==, !=, <, >, <=, >=
	// 참(1), 거짓(0)


	// 비교구문
	// if, else
	// switch, case
	int data = 0;
	if (100 && 200)
	{
		data = 100;
	}
	if (0 && 200)
	{
		// if가 참이면 여기
	}
	else
	{
		// if가 거짓이면 여기
	}
	// 디버그 모드는 컴파일러 최적화가 작동되지 않는다
	// 실제로 코드를 실행하면 if문의 경우 컴파일러 최적화에 의해서 코드가 아예 사라질 수도 있다. 즉, 실행이 될 수도 안될 수도 있다.
	if (0 && 200)
	{
		// if가 참이면 여기
	}
	else if ()
	{
	}
	else if ()
	{
	}
	else if ()
	{
	}
	else
	{
		// if가 거짓이면 여기
	}

	switch (10)
	{
	case 10:

		break;
	case 20:

		break;
	default:

		break;
	}

	switch (10)
	{
	case 10:
	case 20:
	case 30:
		// 의도적으로 break를 한군데만 적어서 10, 20, 30일때 작동하게 만들 수 있다.
		break;
	default:

		break;
	}


	// 삼항 연산자
	// if else 문법을 간략하게 쓰고 싶을때 사용
	// ?:
	int iTest = 10;
	iTest == 20 ? iTest = 100 : iTest = 200;


	// 


	return 0;
}
