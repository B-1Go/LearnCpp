// C++ 에서 #이라는 구문으로 전처리를 지원한다. 전처리는 말 그대로 먼저 수행한다는 뜻이다.
// 컴파일러가 작성된 코드를 보기전에 #구문을 먼저 수행하고 코드를 본다.
#define HUNGRY  1
// 정의 전처리(매크로)를 활용해서 HUNGRY를 1로 지정
// 가독성 및 유지보수 이점
#define THIRSTY 2
#define TIRED   4
#define FIRE    8
#define COLD    16
#define POISON  32

// 보통은 16진수로 표현을 한다.
#define six   0x001
#define six1  0x002
#define six2  0x004
#define six3  0x008

#define six4  0x010
#define six5  0x020
#define six6  0x040
#define six7  0x080

#define six8  0x100
#define six9  0x200
#define six10 0x400
#define six11 0x800


// 주석
//  설명 역할, 코드로 인식되지 않는다.

// 전역변수
int global = 0;

int Add(int left, int right)
{
	return left + right;
}


// 함수
int main()
{
	// 자료형 (크기 단위, 1byte = 8bit) Data Type
	// 정수형 : char(1), short(2), int(4), long(4), long long(8)
	// 실수형 : float(4), double(8)
	int i = 0;
	unsigned char c = 0; // 양의 정수만

	c = 0; // 256가지 -> 0~255
	c = 256; // 1 0000 0000 => 8개만 읽으면 0	9번째 비트는 1바이트에 담을 수 없기 때문에 무시

	// 기본적으로 signed로 되어있고 생략되있다.
	signed c1 = 0; // 256가지 -> -128~127
	// 맨끝(왼쪽끝) Most Siginficant Bit(MSD) 0: 양수, 1: 음수
	c1 = -1;

	// 컴퓨터는 모든 연산을 가산으로 처리하기 때문에
	// 음수의 접근방식을 바꿔서 생각해야 한다.
	// 컴퓨터 에게 음수란 10 + (-10) = 0 -> 즉, 더했을 때 모든 비트가 0이 되버리면 음수이다.
	// 따라서 0000 0001 + 1111 1111 = 1 0000 0000 이 되므로 255는 -1이 된다. 따라서 1000 0001 = -128 이 된다. 반대도 가능하다!

	c = 255; // 255
	c1 = 255; // -1
	// 질문 : c와 c1의 비트상태는 다를까?
	// 답 : 아니다
	// c = 255; 와 c1 = 255; 둘의 비트 상태는 같다. c 는 255가 출력되고 c1는 음수를 표현하기때문에 -1로 출력된다.
	// 메모리안에 들어있는 값이 같아도 어떻게 해석하는가에 따라서 출력 값이 달라진다.

	// 음의 정수 찾기(2의 보수법)
	// 대응되는 양수의 부호를 반전 후, 1을 더한다.

	// long과 int둘 다 4바이트인데 뭔차이냐?
	// 원래 long이 4바이트로 설계 怜 int는 가변적으로 사용하는 거였는데
	// 사용하다보니 int도 4바이트가 榮

	// 컴퓨터에서 실수는 부동소수점으로 동작한다
	// 정수형 방식과 실수 표현 방식은 다르다
	// 실수 표현방식은 정밀도에 의존한다.
	// 따라서 double(8) 자료형이 float(4) 보다 더 아래의 소수점까지 정확하게 표현이 가능하다.

	// 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.
	float f = 10.2415f + (float)20;

	
	// 연산자
	// 대입연산자, =

	// 산술 연산자
	// +, -, *, /, %(모듈러스, 나머지, 피연산자가 모두 정수일때만 가능)
	// ++, --
	int data = 10 + 10; // 연산자 사이에 순서가 있다. = 대입연산자도 연산자이다.
	data = data + 20;
	data += 20; // 위에 수식과 같은 뜻이다.

	// data = 10. % 3.;
	// data = (int)(10. / 3.); // 형변환
	// 10.1 -> 디폴트는 double(8)로보고, 뒤에 10.1f를 붙이면 float(4)로 본다.


	// 보통 증감연산자를 ++: 1증가한다. --: 1감소한다 라고 설명한는데
	// 증감연산자 -> 한단계 증가 또는 감소 개념으로 생각하자.
	// 포인터나 수행되는 위치에 따라서 개념이 달라질 수 있기 때문이다.

	data = 0;
	++data; // 전위(전치)
	data++; // 후위(후치)
	// 후위의 경우 모든 연산자(대입연산자)보다 순서가 늦게 수행된다.

	data = 0;
	int a = 10;
	data = a++; // 이경우 10을 data에 넣고 a가 1증가한다. ++가 대입연산자보다 늦게 수행되기 때문이다.
	// 증감연산자는 변수자체의 메모리의 값을 증가시키기 때문에 따로 대입하거나 할 필요가 없다.


	// 논리 연산자
	// !(역, 반전), &&(곱, and), ||(합, or)
	// 참(True), 거짓(False)
	// 참   : 0 이 아닌 값, 보통 1
	// 거짓 : 0

	// cpp 에서 키워드로 값을 사용할 수 있게 해준다.
	true; // 0이 아닌값
	false; // 0 값

	// bool 자료형
	// 0 또는 1 밖에 모르는 바보
	bool TorF = 100; // 0이 아닌 모든 수는 True 즉 1이 저장된다.
	// bool 도 정수형 자료형으로 볼 수 있으며 0과 1만 사용한다. 크기는 1바이트다.

	int iTrue = 100;
	iTrue = !iTrue;
	// 논리연산자 ! 를 일반자료형에서 쓰면 Ture 또는 False로 받아들여 연산해준다.
	// 즉, 0이 아닌 모든 수는 True로 본다음 -> false인 0값으로 반전시켜 주고
	// False일 경우 1로 반전시켜서 준다.

	iTrue = 0;
	iTrue = 100 && 200; // 논리곱(and) 양쪽다 같으면 참, 하나라도 다르면 거짓
	iTrue = 0 || 1; // 논리합(or) 하나라도 참이면 

	// 비교연산자
	// ==, !=, <, >, <=, >=
	// 참(1), 거짓(0)


	// 비교구문
	// if, else
	// switch, case
	int data = 0;
	if (100 && 200)
	{
		data = 100;
	}
	if (0 && 200)
	{
		// if가 참이면 여기
	}
	else
	{
		// if가 거짓이면 여기
	}
	// 디버그 모드는 컴파일러 최적화가 작동되지 않는다
	// 실제로 코드를 실행하면 if문의 경우 컴파일러 최적화에 의해서 코드가 아예 사라질 수도 있다. 즉, 실행이 될 수도 안될 수도 있다.
	if (0 && 200)
	{
		// if가 참이면 여기
	}
	else if ()
	{
	}
	else if ()
	{
	}
	else if ()
	{
	}
	else
	{
		// if가 거짓이면 여기
	}

	switch (10)
	{
	case 10:

		break;
	case 20:

		break;
	default:

		break;
	}

	switch (10)
	{
	case 10:
	case 20:
	case 30:
		// 의도적으로 break를 한군데만 적어서 10, 20, 30일때 작동하게 만들 수 있다.
		break;
	default:

		break;
	}


	// 삼항 연산자
	// if else 문법을 간략하게 쓰고 싶을때 사용
	// ?:
	int iTest = 10;
	iTest == 20 ? iTest = 100 : iTest = 200;


	// 비트 연산자
	// 쉬프트 <<. >>
	unsigned char byte = 1;
	byte <<= 1; // 같음 byte = byte << 1;

	byte <<= 2; // 2^n 배수
	byte >>= 3; // 2^n 나눈 몫

	// 비트 곱(&), 합(|), xor(^), 반전(~)
	// 비트단위로 연산을 진행
	// & 둘다 1인 경우 1
	// | 둘중 하나라도 1이면 1,
	// ^ 같으면 1 다르면 0,
	// ~ 1은 0으로, 0은 1로
	// 비트연산 게임에서는 전처리로 자줄 쓰인다.
	// 맨 첫줄에 적음

	unsigned int iStats = HUNGRY;
	// #define 구문으로 정의를 했기 때문에 Stats에는 HUNGRY 단어처럼 보이지만 1이라는 정수형이 들어온다.


	// 비트연산자 활용 방법 (스타에서 유닛 상태를 비트단위로 표현했던거 기억나지? 그거야!)
	iStats = 0; // int(4)이니까 32bit이고 각 자리를 상태로 활용하면 32개의 상태를 정의할 수 있다.
	
	// 상태추가
	iStats |= HUNGRY;
	iStats |= THIRSTY;

	// 상태확인
	if (iStats & THIRSTY)
	{

	}

	// 특정 자리 비트 제거
	iStats &= ~THIRSTY;


	// 변수
	// 1. 지역변수
	// 2. 전역변수
	// 3. 정적변수 (3가지로 나뉨)
	// 4. 외부변수

	
	// 지역변수
	int iName = 0;
	// 지역변수 안에 또 지역변수를 선언할 수 있다.
	// 괄호 안에 선언된 변수(함수, 지역)
	{
		// main이라는 안에서 만들어진 또 새로운 영역
		// 변수명 규칙
		int iName = 0;

		iName;
		{
			{

			}
		}
	}

	iNmae = 100; // 각 지역에 변수만 접근함: 왜? 지역변수니까
	// 따라서 같은 지역에는 같은 변수명을 2번이상 선언 할 수 없다.

	// 함수
	data = Add(10, 20);

	return 0;
}
