// 주석
//  설명 역할, 코드로 인식되지 않는다.

int main()
{
	// 자료형 (크기 단위, 1byte = 8bit) Data Type
	// 정수형 : char(1), short(2), int(4), long(4), long long(8)
	// 실수형 : float(4), double(8)
	int i = 0;
	unsigned char c = 0; // 양의 정수만

	c = 0; // 256가지 -> 0~255
	c = 256; // 1 0000 0000 => 8개만 읽으면 0	9번째 비트는 1바이트에 담을 수 없기 때문에 무시

	// 기본적으로 signed로 되어있고 생략되있다.
	signed c1 = 0; // 256가지 -> -128~127
	// 맨끝(왼쪽끝) Most Siginficant Bit(MSD) 0: 양수, 1: 음수
	c1 = -1;

	// 컴퓨터는 모든 연산을 가산으로 처리하기 때문에
	// 음수의 접근방식을 바꿔서 생각해야 한다.
	// 컴퓨터 에게 음수란 10 + (-10) = 0 -> 즉, 더했을 때 모든 비트가 0이 되버리면 음수이다.
	// 따라서 0000 0001 + 1111 1111 = 1 0000 0000 이 되므로 255는 -1이 된다. 따라서 1000 0001 = -128 이 된다. 반대도 가능하다!

	c = 255; // 255
	c1 = 255; // -1
	// 질문 : c와 c1의 비트상태는 다를까?
	// 답 : 아니다
	// c = 255; 와 c1 = 255; 둘의 비트 상태는 같다. c 는 255가 출력되고 c1는 음수를 표현하기때문에 -1로 출력된다.
	// 메모리안에 들어있는 값이 같아도 어떻게 해석하는가에 따라서 출력 값이 달라진다.

	// 음의 정수 찾기(2의 보수법)
	// 대응되는 양수의 부호를 반전 후, 1을 더한다.

	// long과 int둘 다 4바이트인데 뭔차이냐?
	// 원래 long이 4바이트로 설계 됬고 int는 가변적으로 사용하는 거였는데
	// 사용하다보니 int도 4바이트가 됬다

	// 컴퓨터에서 실수는 부동소수점으로 동작한다
	// 정수형 방식과 실수 표현 방식은 다르다
	// 실수 표현방식은 정밀도에 의존한다.
	// 따라서 double(8) 자료형이 float(4) 보다 더 아래의 소수점까지 정확하게 표현이 가능하다.

	// 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.
	// float f = 10.2415f + (float)20;



	return 0;
}