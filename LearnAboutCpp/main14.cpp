#include <iostream>

#include "Arr.h"

struct tMy
{
	// tMy는 사용자가 정의한 자료형이다.]
	// ]
	// C++ 에서는 typedef 할 필요가 없다
};


class CMy
{
	// Class도 C++에서 사용자가 정의한 자료형이다.
	
	// 접근 제한 지정장
	// private, protected(상속), public

private:
	int m_i;
	float m_f;

public:
	void SetInt(int i)
	{
		m_i = i; // this->m_i = i; 이때 this-> 생략 되어있다.
	}
	// 만약 C 스탈일 이였다면
	void cSetInt(CMy* _this, int i)
	{
		_this->m_i = i;
	}
	// 위와같은 식으로 설계를 해놓고 사용편리를 위해서 감쳐놓은 것이다. 따라서 포인터의 접근은 그대로 이용되고 있다고 볼 수 있다.


	// 대입 연산자
	CMy& operator =(const CMy& _Other)
	{
		this->m_i = _Other.m_i;
		this->m_f = _Other.m_f;

		return *this;
	}
	// operator =
	// 위는 규칙여서 형태를 외우면되고
	// 함수를 호출하는 객체는 CMy& 이고, 인자로는 (const CMy& _Other)이 된다. -> 함수의 형태이기 때문에 연산자오버로딩이라고 부른다 결국 함수오버로딩과 같다.
	// 같은 함수명이여도 인자값이 달라서 동일 함수명이 가능한 것을 오버로딩이라고 한다.
	// 위에 반환타입이 레퍼런스 참조 인데 return *this인 이유는
	// c = c2 = c3; 일때 c2 = c3 연산이 먼저 일어나고 c = c2; 연산이 일어나는데
	// 만약 void로 한다면 c2 = c3 연산이 끝나고 (-> 함수를 호출하고 종료되기 때문) 반환된 값이 없으면
	// c = c2; 연산이 c = ; 형태가 되어서 기본자료형에서 제공하는 기능이 구현이 안되기 때문이다.

public:
	// 생성자
	// 이니셜라이져(생성과 동시에 작업을 함)
	CMy()
		: m_i(100) // 이게 이니셜라이져임
		, m_f(3.14f)
	{
		// m_i = 100; // 이건 진정한 초기화가 아님, 생성자가 이미 만들고 그 만들어진 곳에 100을 넣으라는 작업이므로 2단계가 되기 때문이다.
	}


	// 소멸자
	~CMy()
	{

	}

	// C++ 구조상 생성자와 소멸자를 작성안하면 컴파일러가 자동으로 채운다. 단 아무기능이 없다.
};

void Test()
{

}



int main()
{
	// C++ 클래스 특징
	// 접근제한 지정자
	// 클래스 내의 멤버변수 or 멤버함수 의 접근 레벨

	// 생성자, 소멸자
	// 객체 생성, 소멸 시 자동으로 호출(컴파이러가 해줌)
	// 직접 만들지 않으면 기본 생성자, 기본 소멸자가 만들어짐
	
	// 멤버함수
	// 해당클래스가 사용하는 전용 함수
	// 해당클래스의 객체가 필요함
	// 멤버함수 객체를 통해서 호출하면, 해당 객체의 주소가 this 포인터로 전달된다.


	{
		// 레퍼런스
		// 자료형 * 변수명;   포인터 변수 선언
		// *포인터변수;       포인터로 주소 역참조
		// &변수;             변수의 주소값
		// 자료형 & 변수명;   레퍼런스 변수 선언

		// c++ 에 추가된 기능
		// 포인터와 유사
		// 원본을 참조한다.
		// 참조변수를 통해서 직접적으로 원본을 수정 할 수 있다.

		int a = 10;

		int* const p = &a;
		*p = 100;

		int& iRef = a;
		iRef = 100;
		// 레퍼런스의 어셈블리 코드는 포인트랑 똑같다. 그러나 사용하는 입장에서는 좀 다른 형태일 뿐이다.
		// 레퍼런스는 위와같이 const 기능이 포함된 포인터라고 생각할 수 있다.
		// 한번 참조가 되면 다른 포인터를 받을 수 없다. 완전히 const 포인터랑 같다.
		// 장점! 포인터 역참조 방식이 아니라 바로 접근해서 수정할 수 있는 형태여서, 포인터 역참조로는 만들 수 없는 구조에 활용 할 수 있다.


		const int* const p2 = &a;
		// *p2 = 10;

		const int& iRefConst = a;
		// iRefConst = 10;

		// 원본 값을 수정도 못하고 참조도 못하고
		// 결과적으로 레퍼런스는 const를 기본적으로 가지고 있는 포인터라고 볼 수 있다.
	}

	Test();

	// CMy::SetInt(1000); // CMy라는 클래스의 함수를 :: 범위로 지정해서 가져올 수 있다. 하지만 해당 클래스의 객체가 불러올 수 있다.

	tArr arr = {};
	InitArr(&arr);
	PushBack(&arr, 10);

	ReleaseArr(&arr);


	CMy c; // 생성자는 객체가 만들어질때 자동으로 호출되는 기능이다.
	// c.m_i = 0;
	c.SetInt(10);

	CMy c2;
	c2.SetInt(100);

	CMy c3;
	c3.SetInt(1000);

	c3 = c2; // 방금 새로만든 구조체이므로 컴파일러가 미리 알고 있을 수 없다.
	// 일반 자료형일때 대입연산자가 이우러지는 것 처럼 어떻게 새로운 자료형끼리 대입연산이 이루어질 쑤 있을까? -> 컴파일러가 대입연산자는 자동으로 만들어 준다.
	
	// c3 + c2;
	// 더하기 마저 어떠한 함수를 호출하는 특정한 조건으로 볼수 있다. 마치 대입연산자 처럼말이다. 따라서 너가 원하는 기능은 너가 만들수 있다.
	// 기존은 기본 자료형은 알아서 됬는데 같은 기호에 같은 함수를 넣는 것을 잘 생각해보면 같은 함수명을 짓는거과 같다 따라서
	// 이걸 "연산자오버로딩"이라고 한다. 마치 함수 오버로딩과 같은 개념인 것이다.

	int i = 0;
	int i2 = 5;
	int i3 = 10;

	i = i2 = i3; // i3값을 i2에 넣고, i2값을 i에 넣는다.

	return 0;
}